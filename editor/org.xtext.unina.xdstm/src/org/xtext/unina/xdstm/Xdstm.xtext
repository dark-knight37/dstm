// automatically generated by Xtext
grammar org.xtext.unina.xdstm.Xdstm with org.eclipse.xtext.common.Terminals

generate xDstm "http://www.xtext.org/unina/xdstm/XDstm"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model returns Model:
	include = include
	machines += Machine (machines+=Machine)*
	dstm += DSTM;

include returns include:
	'import' importURI=STRING ';';
 
DSTM returns DSTM:
	'DSTM' name=ID '{'
		'machines' '=' machines+=[Machine] ( "," machines+=[Machine])* ';'
		'main' main=[Machine] ';'
	'}' ';';

Machine returns Machine:
	'Machine'
	name=ID //'(' parameters+=Parameter ( ',' parameters+=Parameter) ')'
	'{'
		'vertexes' '{' 
			vertexes+=Vertex ( ',' vertexes+=Vertex)*
		'}'
		'transitions' '{'
			transitions+=Transition ( ',' transitions+=Transition)* 
		'}'
	'}' ';';


Vertex returns Vertex:
	Node | Box | EnteringNodeAbs | ExitingNode | Fork | Join;

EnteringNodeAbs returns EnteringNodeAbs:
	EnteringNode | InitialNode;

Node returns Node:
	'Node' name=ID
	requirements = Requirements;

Box returns Box:
	'Box' name=ID
	requirements = Requirements
	'{'
		'instantiation' '(' instantiation+=[Machine] ( "," instantiation+=[Machine])* ')' 
	'}';

EnteringNode returns EnteringNode:
	'EnteringNode' name=ID
	requirements = Requirements;
	
InitialNode returns InitialNode:
	'InitialNode' name=ID 
	requirements = Requirements;

ExitingNode returns ExitingNode:
	'ExitingNode' name=ID
	requirements = Requirements;

Fork returns Fork:
	'Fork' name=ID
	requirements = Requirements;

Join returns Join:
	'Join' name=ID
	requirements = Requirements;

Destination:
	Node | Box | ExitingNode | Fork | Join;
	
Source:
	Node | Box | EnteringNodeAbs | Fork | Join;

Transition returns Transition:
	'Transition' name=ID
	requirements = Requirements
	'{'
		'source' source = [Source]
		(',' 'exiting_node' exiting_node=[ExitingNode|EString])?
		',' 'destination' destination=[Destination]
		(',' 'entering_node' entering_node=[EnteringNodeAbs|EString])?
		(',' is_preemptive?='isPreemptive')?
		(',' 'trigger' trigger=STRING)?
		(',' 'condition' condition=STRING)?
		(',' 'actions' '{' actions+=STRING ( ',' actions+=STRING)* '}')?
		(',' 'par_instantiation' '{' par_instantiation+=STRING ( ',' par_instantiation+=STRING)* '}')?
	'}';

Requirements returns requirements:
	{requirements}
	('(' 'requirements' '=' requirements+=STRING ( "," requirements+=STRING )* ')')?;
	
EString returns ecore::EString:
	STRING | ID;